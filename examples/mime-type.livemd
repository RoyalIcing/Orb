# Orb Mime Type

```elixir
Mix.install([
  :orb,
  {:wasmex, "~> 0.8.3"},
  {:kino, "~> 0.12.0"}
])
```

## Define our Mime Type module using Orb

```elixir
defmodule MimeType do
  use Orb

  Memory.pages(1)

  defw(txt, I32.UnsafePointer, do: "text/plain")
  defw(html, I32.UnsafePointer, do: "text/html")
  defw(css, I32.UnsafePointer, do: "text/css")
  defw(json, I32.UnsafePointer, do: "application/json")
  defw(js, I32.UnsafePointer, do: "application/javascript")
  defw(csv, I32.UnsafePointer, do: "text/csv")
  defw(sqlite, I32.UnsafePointer, do: "application/vnd.sqlite3")
end
```

## We can run the WebAssembly module in Elixir using Wasmex

```elixir
file_extension = "csv"

{:ok, pid} = Wasmex.start_link(%{bytes: Orb.to_wat(MimeType)})

{:ok, memory} = Wasmex.memory(pid)
{:ok, store} = Wasmex.store(pid)
byte_count = Wasmex.Memory.size(store, memory)

bytes = Wasmex.Memory.read_binary(store, memory, 0, byte_count)

case Wasmex.call_function(pid, file_extension, []) do
  {:ok, [str_ptr]} ->
    <<_::binary-size(str_ptr), slice::binary>> = bytes
    # slice = binary_slice(bytes, str_ptr..-1//1)
    for(<<chunk::size(8) <- slice>>, do: chunk)
    |> Enum.take_while(fn c -> c != 0 end)
    |> List.to_string()

  {:error, _} ->
    nil
end
```
